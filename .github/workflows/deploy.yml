name: Deploy MCP Server to AWS Lambda

on:
  workflow_dispatch:
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: eu-central-1
  FUNCTION_NAME: mini-mcp-server
  LAMBDA_ARCHITECTURE: x86_64  # Change to arm64 if you want ARM64 Lambda

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install uv
        uses: astral-sh/setup-uv@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create deployment package
        run: |
          chmod +x create_deployment_package.sh
          ./create_deployment_package.sh

      - name: Deploy to Lambda
        run: |
          # Check if function exists
          if aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} >/dev/null 2>&1; then
            echo "Updating existing function..."
            aws lambda update-function-code \
              --function-name ${{ env.FUNCTION_NAME }} \
              --zip-file fileb://mcp-server-deployment.zip
          else
            echo "Creating new function..."
            
            # Create IAM role
            aws iam create-role \
              --role-name mini-mcp-server-role \
              --assume-role-policy-document '{
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Principal": {
                      "Service": "lambda.amazonaws.com"
                    },
                    "Action": "sts:AssumeRole"
                  }
                ]
              }' || echo "Role may already exist"
            
            # Attach policies
            aws iam attach-role-policy \
              --role-name mini-mcp-server-role \
              --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole || true
            
            aws iam attach-role-policy \
              --role-name mini-mcp-server-role \
              --policy-arn arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess || true
            
            # Wait for role to be ready
            sleep 10
            
            # Get role ARN
            ROLE_ARN=$(aws iam get-role --role-name mini-mcp-server-role --query 'Role.Arn' --output text)
            
            # Create Lambda function
            aws lambda create-function \
              --function-name ${{ env.FUNCTION_NAME }} \
              --runtime python3.12 \
              --role $ROLE_ARN \
              --handler lambda_handler.lambda_handler \
              --zip-file fileb://mcp-server-deployment.zip \
              --architecture ${{ env.LAMBDA_ARCHITECTURE }} \
              --memory-size 512 \
              --timeout 30
          fi

      - name: Wait for Lambda to be ready
        run: |
          echo "Waiting for Lambda function to be ready..."
          for i in {1..30}; do
            STATE=$(aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} --query 'Configuration.State' --output text 2>/dev/null || echo "Unknown")
            echo "Attempt $i: Function state is $STATE"
            if [ "$STATE" = "Active" ]; then
              echo "Function is ready!"
              break
            elif [ "$STATE" = "Failed" ]; then
              echo "Function creation failed!"
              exit 1
            fi
            sleep 10
          done
          
          if [ "$STATE" != "Active" ]; then
            echo "Function did not become active within 5 minutes"
            exit 1
          fi

      - name: Test deployment
        run: |
          # Create test payload file to avoid encoding issues
          cat > test-payload.json << 'EOF'
          {
            "version": "2.0",
            "routeKey": "POST /mcp",
            "rawPath": "/mcp",
            "rawQueryString": "",
            "headers": {
              "content-type": "application/json",
              "host": "localhost"
            },
            "requestContext": {
              "http": {
                "method": "POST",
                "path": "/mcp",
                "protocol": "HTTP/1.1",
                "sourceIp": "127.0.0.1",
                "userAgent": "test-agent"
              },
              "requestId": "test-request-id",
              "accountId": "123456789012",
              "apiId": "test-api-id",
              "stage": "test"
            },
            "body": "{\"jsonrpc\": \"2.0\", \"id\": 1, \"method\": \"tools/list\", \"params\": {}}",
            "isBase64Encoded": false
          }
          EOF
          
          # Test the MCP function with retry logic
          echo "Testing Lambda function..."
          for i in {1..5}; do
            echo "Test attempt $i..."
            if aws lambda invoke \
              --function-name ${{ env.FUNCTION_NAME }} \
              --payload fileb://test-payload.json \
              response.json; then
              echo "MCP Function response:"
              cat response.json
              break
            else
              echo "Test failed, retrying in 10 seconds..."
              sleep 10
            fi
          done
          
          # Clean up
          rm test-payload.json

      - name: Create API Gateway
        run: |
          # Clean up existing API Gateways with the same name
          echo "Cleaning up existing API Gateways..."
          aws apigateway get-rest-apis --query 'items[?name==`mini-mcp-server-api`].[id]' --output text | while read api_id; do
            if [ ! -z "$api_id" ]; then
              echo "Deleting existing API Gateway: $api_id"
              aws apigateway delete-rest-api --rest-api-id $api_id || echo "Failed to delete $api_id, continuing..."
            fi
          done
          
          # Wait a moment for cleanup
          sleep 5
          
          # Create API Gateway
          API_ID=$(aws apigateway create-rest-api --name mini-mcp-server-api --query 'id' --output text)
          ROOT_ID=$(aws apigateway get-resources --rest-api-id $API_ID --query 'items[0].id' --output text)
          
          # Create /mcp endpoint
          MCP_ID=$(aws apigateway create-resource --rest-api-id $API_ID --parent-id $ROOT_ID --path-part mcp --query 'id' --output text)
          aws apigateway put-method --rest-api-id $API_ID --resource-id $MCP_ID --http-method POST --authorization-type NONE
          
          # Get Lambda function ARN
          LAMBDA_ARN=$(aws lambda get-function --function-name ${{ env.FUNCTION_NAME }} --query 'Configuration.FunctionArn' --output text)
          aws apigateway put-integration --rest-api-id $API_ID --resource-id $MCP_ID --http-method POST --type AWS_PROXY --integration-http-method POST --uri "arn:aws:apigateway:${{ env.AWS_REGION }}:lambda:path/2015-03-31/functions/$LAMBDA_ARN/invocations"
          
          # Deploy and set permissions
          aws apigateway create-deployment --rest-api-id $API_ID --stage-name prod
          
          # Get AWS account ID for proper ARN
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          
          # Create unique statement ID with timestamp
          STATEMENT_ID="apigateway-invoke-$(date +%s)"
          
          # Add permission with specific source ARN for the /mcp endpoint
          aws lambda add-permission \
            --function-name ${{ env.FUNCTION_NAME }} \
            --statement-id $STATEMENT_ID \
            --action lambda:InvokeFunction \
            --principal apigateway.amazonaws.com \
            --source-arn "arn:aws:execute-api:${{ env.AWS_REGION }}:$ACCOUNT_ID:$API_ID/*/POST/mcp" || echo "Permission may already exist, continuing..."
          
          # Wait for deployment to complete
          sleep 3
          
          # Output endpoint URL
          API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod"
          echo "MCP Endpoint: $API_URL/mcp"
          echo "Health Check: $API_URL/health"

      - name: Wait for API Gateway deployment
        run: |
          echo "Waiting for API Gateway deployment to complete..."
          sleep 30

      - name: Test API Gateway
        run: |
          # Get the API Gateway URL
          API_ID=$(aws apigateway get-rest-apis --query 'items[?name==`mini-mcp-server-api`].[id]' --output text | head -1)
          API_URL="https://$API_ID.execute-api.${{ env.AWS_REGION }}.amazonaws.com/prod"
          
          echo "API Gateway URL: $API_URL"
          
          # Test health endpoint with retry
          echo "Testing health endpoint..."
          for i in {1..3}; do
            if curl -X GET "$API_URL/health" --max-time 30; then
              echo "Health check passed!"
              break
            else
              echo "Health check attempt $i failed, retrying..."
              sleep 10
            fi
          done
          
          # Test MCP endpoint with retry
          echo "Testing MCP endpoint..."
          for i in {1..3}; do
            if curl -X POST "$API_URL/mcp" \
              -H "Content-Type: application/json" \
              -d '{"jsonrpc": "2.0", "id": 1, "method": "tools/list", "params": {}}' \
              --max-time 30; then
              echo "MCP test passed!"
              break
            else
              echo "MCP test attempt $i failed, retrying..."
              sleep 10
            fi
          done
